---
layout: post
title: LUA的WEB框架与C语言SO库
date:   2017-02-03 11:00:18 +0800 
categories: candylab
---


作者：糖果

之前小伙伴们讨论，是否有必要在lua写的web框架中引入c语言。是否可以把灯泡放到嘴里含一下?
小伙伴们说的道理太深了，有时也听不懂，然后就做了下面这个小测验，实现一个小目标，在HiLua
工程中，加入一个.so的生成lib，把之前写的测试程序加进来，通过Makefile生成、安装、删除so库
然后，用HiLua自动生成.so的调用lua程序。

在测试的过程中，有几点可能值得注意一下：

1. C与Lua之间传递各位数据类和数据结构的方式。
2. 调用SO库对那个非阻塞业务有那些影响。
3. SO库这种形式，相对比较适合封装那些库。

类似LOR或Django这种框架，会把一个共通的APP变成一个中间件，甚至可以揉合到路由，.SO是一个
系统级的共享库，与路由发生功能耦合而不是数据耦合相对更好一些，保持不粘连非共通性的业务
做纯层次的功能支持，这是设计时考虑到这种粒度的库的基本耦合原则。


引入C代码，可能就意味着要引入段错误等更低级的调试工作在开发过程中，涉及到这部分内容需要
改Makefile,让工程生成CoreDump文件，这种情况有时就像灯泡放嘴里拿不出来，需要有人出手帮忙。


将Lua引入C，可以从某种程序降低开发难度，提搞开发生产性，而这个测试正好相反，这也就又回到了上
面所说的第三个问题，Lua重新引入C是有代价的，所以，我们要干点有意义的事，打个print！先实现了
一个小目标。


tangguo.h

```c
extern int prn(lua_State* L); 

static luaL_Reg libtangguo[] = { 
    {"add", add},
    {"sub", sub},
    {"prn", prn},
    {NULL, NULL}
};


```


tangguo.c

```c
int prn(lua_State* L) {
    puts("CandyLab, Hi LUA!");
    return 1;
}
```

按照上面这种测试方法，我们可以很快的断定，这代码没什么用啊！这样我们就又有了新的小
目标。

1.  通过SO库调用wx。
2.  通过SO库调用文件IO API。
3.  通过SO库调用Socket API。

在实现小目标之前，我们要加大so库函数的入参和返回值传递的数据结构的复杂度，适应更
复杂的需求，比常用数据类型更复杂的可以是structure或lua table了，这是码农的基本素养
：用程序语言在计算机软件系统中搬运数据，不会开发的运维搞不好安全。


 先看看到底有多少的API可供我们使用，那直接看lauxlib.h文件。
 
 
 
 
~~~c
 
#define luaL_argcheck(L, cond,numarg,extramsg)  \
                ((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
#define luaL_checkstring(L,n)   (luaL_checklstring(L, (n), NULL))
#define luaL_optstring(L,n,d)   (luaL_optlstring(L, (n), (d), NULL))
#define luaL_checkint(L,n)      ((int)luaL_checkinteger(L, (n)))
#define luaL_optint(L,n,d)      ((int)luaL_optinteger(L, (n), (d)))
#define luaL_checklong(L,n)     ((long)luaL_checkinteger(L, (n)))
#define luaL_optlong(L,n,d)     ((long)luaL_optinteger(L, (n), (d)))

#define luaL_typename(L,i)      lua_typename(L, lua_type(L,(i)))

#define luaL_dofile(L, fn) \
        (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_dostring(L, s) \
        (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_getmetatable(L,n)  (lua_getfield(L, LUA_REGISTRYINDEX, (n)))

#define luaL_opt(L,f,n,d)       (lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))


~~~


然后再看看，有那些复杂的数据结构：


```c

LUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
LUALIB_API char *(luaL_prepbuffer) (luaL_Buffer *B);
LUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
LUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);
LUALIB_API void (luaL_addvalue) (luaL_Buffer *B);
LUALIB_API void (luaL_pushresult) (luaL_Buffer *B);

```


从手册里复制一段代码过来：


```c

int split(lua_State* L) {
    const char *s = luaL_checkstring(L, 1); 
    const char *sep = luaL_checkstring(L, 2); 
    const char *e; 
    int i = 1;
 
    lua_newtable(L);  /* result */
 
    /* repeat for each separator */
    while ((e = strchr(s, *sep)) != NULL) {
       lua_pushlstring(L, s, e-s);  /* push substring */
       lua_rawseti(L, -2, i++);
       s = e + 1;  /* skip separator */
    }

    /* push last substring */
    lua_pushstring(L, s);
    lua_rawseti(L, -2, i);

    //puts(s);
    //puts(sep);
    puts("Split");
    return 1;  /* return the table */
}

```

Lua调用


```lua
local ret = asplit("hi,,there",",")

for k,v in pairs(ret) do
    print(k, v)
end
```

又是strchr函数，有很多C系统都是用strchr做字符串分割，套用上面的实现让Lua支持了C级别
的Split而不是Lua脚本实现的split，性能差多少看时间戳。

```c
    const char *s = luaL_checkstring(L, 1); 
    lua_newtable(L);  /* result */
    lua_pushstring(L, s);
    lua_rawseti(L, -2, i);
```

Lua在调用C写的SO库时，库中C函数的C函数本身的"return", 不是给Lua调用者返回的结果 
真正的返回结果是靠Lua_pushXXX通过lua栈返回的，相应的lua调用者传递的入参是靠
luaL_checkXX这种孙数取得的，我们简化上面的split函数，只让函数，接入Lua传入的字符
串参数，然后将对应传入的字符串放到一个 lua_newtable创建的Table结构中，返回给Lua
调用者。


tangguo.c


```c
int itable(lua_State* L) {
    const char *s = luaL_checkstring(L, 1);
    const char *sep = luaL_checkstring(L, 2);

    lua_newtable(L);  /* result */

    /* push last substring */
    lua_pushstring(L, s);
    lua_rawseti(L, -2, 1);

    lua_pushstring(L, sep);
    lua_rawseti(L, -2, 2);
    return 1;  /* return the table */
}
```

test.lua

```lua
local itable = package.loadlib("libtangguo.so", "itable")

local ret = itable("elementA","elementB")
for k,v in pairs(ret) do
    print(k, v)
end
```

在C代码中,向Table中插入数据，有两种方式：

方式1：

```c
const char *value = luaL_checkstring(L, 1);
lua_pushstring(L, value);  
lua_rawseti(L, -2, i++);  
```

方式2：

```c
const char *value = luaL_checkstring(L, 1);
lua_pushnumber(L, 1);    //key  
lua_pushstring(L, value);  //value  
lua_settable(L, -3);       //push key,value  
```

以上的itable函数就实现了返回一个Lua Table结构的功能：


另外，luaxlib.h库，还提供一个数据结构方便操作字符，就是luaL_Buffer，还
提供了对应的操作函数，来方便的操作字符串数据，而简化内存操作,具体机制
类似, 数据结构声明，如下：


```c
typedef struct luaL_Buffer {
  char *p;                      /* current position in buffer */
  int lvl;  /* number of strings in the stack (level) */
  lua_State *L; 
  char buffer[LUAL_BUFFERSIZE];
} luaL_Buffer;
```


以上的split这种C代码都是原生的C代码，没有封装任何的API和库。
而wxWidgets是下一步想加入测试的库，其实wxWidgets对应的已经有了wxLua，不想
离题太远的话，就先到这，什么情况代码不用Lua，非要用C写？ 其实，还可以用
MoonScript写库，翻译成Lua后给框架使用。





<a href="https://github.com/shengnoah/hilua/tree/libs/libs/so" target="_blank">源码地址：</a>

PS:转载到其它平台请注明作者姓名及原文链接，请勿用于商业用途。

[糖果实验室](http://www.candylab.net)

http://www.candylab.net

