---
layout: post
title:  "Luabit的位运算简介"
date:   2016-09-17 22:50:18 +0800
categories: jekyll update
---

作者：糖果

<h3>Luabit的位运算</h3> 

Lua提供了bit库，可以对变量数据进行位运算，在某些应有场景，我们得确需要在lua中对数据进行位移，或是进行“与，或，非”，进制转换等操作。

例如有这么一种较典型的情况，我们用一个32位的整数表示RGB颜色,32位整数，被分为4个部分，每个部分8bit, 8bit可表示的10进制数的范围是0~255。

我们现在有一组RGB的颜色值: Alpha通道=8, R=4, G=2, B=1

```
下面是,二进制表示：
Alpha    Red      Green    Blue
00001000 00000100 00000010 00000001
第四组    第三组    第二组    第一组


下面是,十六进制表示：
Alpha   Red    Green   Blue
0x08    0x04   0x02    0x01
第四组   第三组  第二组  第一组


下面是,十进制表示：
134480385
```

我们现在要作的是把整数"134480385"的“4组”“8bit”数据截取出来。
思路和C语言二进制运算是一样，首先是“4组“每”8bit“的数据，都移动到”第一组的“位置，每一组不需要移位，然后是，第次移位后和0x000000FF这个数进行"AND"运算，清空前24位数据，保留最后的8位bit数据。

<strong>需要分解的原始数据：</strong> 


```lua
local num = bit.tobit(0x08040201)
print(num)
```



<strong>第一组Blue数据的取得：</strong> 

```
8        4        2        1
Alpha    Red      Green    Blue
00001000 00000100 00000010 00000001
第四组    第三组    第二组    第一组
```

第一组的数据，不需要移位操作，直接将数据与"0x000000FF"进行”与“运算。

```
8        4        2        1
Alpha    Red      Green    Blue
00001000 00000100 00000010 00000001
And（与运算）
00000000 00000000 00000000 11111111
结果（1）
00000000 00000000 00000000 00000001
第四组    第三组    第二组    第一组
```


```lua
local t_num = num
local blue = bit.band(t_num, 0x000000ff)
print("blue:"..blue)
```


<strong>第二组Green数据的取得：</strong> 

第二组Green数据，需要先右移8位，然后，才能与"0x000000FF"进行”与“运算。

```
8        4        2        1
Alpha    Red      Green    Blue
00001000 00000100 00000010 00000001
RShift(右移8位，左边空位补零)
00000000 00001000 00000100 00000010 
And（与运算）
00000000 00000000 00000000 11111111
结果（2）
00000000 00000000 00000000 00000010
第四组    第三组    第二组    第一组
```


```lua
local t_num = bit.rshift(num, 8)
local green = bit.band(t_num, 0x000000ff)
print("green:"..green)
```


<strong>第三组Red数据的取得：</strong> 

第三组Red数据，需要先右移16位，然后，才能与"0x000000FF"进行”与“运算。

```
8        4        2        1
Alpha    Red      Green    Blue
00001000 00000100 00000010 00000001
RShift(右移16位，左边空位补零)
00000000 00000000 00001000 00000100 
And（与运算）
00000000 00000000 00000000 11111111
结果（4）
00000000 00000000 00000000 00000100
第四组    第三组    第二组    第一组
```


<strong>第四组Alpha数据的取得：</strong> 

第四组Alpha数据，需要先右移24位，然后，才能与"0x000000FF"进行”与“运算。

```
8        4        2        1
Alpha    Red      Green    Blue
00001000 00000100 00000010 00000001
RShift(右移24位，左边空位补零)
00000000 00000000 00000000 00001000 
And（与运算）
00000000 00000000 00000000 11111111
结果（8）
00000000 00000000 00000000 00001000
第四组    第三组    第二组    第一组
```

<strong>最后，取得四组数据的值：</strong>  Alpha通道=8, R=4, G=2, B=1


<h3>下面是Lua代码：</h3> 

```lua
local bit = require "bit"
local num = bit.tobit(0x08040201)
print(num)

--第一组Blue数据的取得：
local t_num = num
local blue = bit.band(t_num, 0x000000ff)
print("blue:"..blue)

--第二组Green数据的取得：
local t_num = bit.rshift(num, 8)
local green = bit.band(t_num, 0x000000ff)
print("green:"..green)

--第三组Red数据的取得：
local t_num = bit.rshift(num, 16)
local red = bit.band(t_num, 0x000000ff)
print("red:"..red)

--第四组Alpha数据的取得：
local t_num = bit.rshift(num, 24)
local alpha = bit.band(t_num, 0x000000ff)
print("alpha:"..alpha)
```


下面是Luabit常用函数：


```lua
{
    ["band"] = function: 0055B430,
    ["rshift"] = function: 0055B530,
    ["bor"] = function: 0055B470,
    ["bnot"] = function: 0055B3F0,
    ["bswap"] = function: 0055B3B0,
    ["bxor"] = function: 0055B4B0,
    ["tobit"] = function: 0055B390,
    ["ror"] = function: 00559C98,
    ["lshift"] = function: 0055B4F0,
    ["tohex"] = function: 0055B610,
    ["rol"] = function: 0055B5B0,
    ["arshift"] = function: 0055B570,
}
```


PS:转载到其它平台请注明作者姓名及原文链接，请勿用于商业用途。

[糖果实验室](http://www.candylab.net)

http://www.candylab.net
